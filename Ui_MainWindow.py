"""
Image Annotator
by Amir Kardoost and Beatriz Fernandes
October 2024
"""

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QRectF
from PyQt5.QtGui import QPixmap, QImage, QIcon, QFont, QColor

import os
from pathlib import Path
import pandas as pd
import cv2
import ast
import csv
from datetime import datetime

from ImageViewer import ImageViewer
from BoundingBox import BoundingBox
from utils import *

class Ui_LogsWindow(QtWidgets.QWidget):  # Define the new window
    def __init__(self):
        super().__init__(None)
        self.setWindowTitle("Logs")
        self.setGeometry(50, 200, 300, 200)

        self.text_browser = QtWidgets.QTextBrowser(self)
        self.text_browser.setGeometry(QtCore.QRect(0, 0, 300, 200))
        self.text_browser.setObjectName("text_browser")

        self.text_browser.setHtml("Hello, welcome! Please load an image (.tif or .nii.gz) and a bounding boxes .csv file!\n")

    def update_message(self, message:str=''):
        current_html = self.text_browser.toHtml()
        
        # Add new content with bold formatting
        new_html = current_html + "<br>" +\
                   str(datetime.now().replace(microsecond=0)) + "<br>" +\
                   message
        
        # Update the QTextBrowser
        self.text_browser.setHtml(new_html)
        # self.textBrowser.append(str(datetime.now().replace(microsecond=0)) + "\n" + message)


class Ui_DrawnBoxesWindow(QtWidgets.QWidget):
    def __init__(self):
        super().__init__(None)
        self.setWindowTitle("Drawn Boxes")
        self.setGeometry(50, 200, 300, 200)


class Ui_MainWindow(QtWidgets.QMainWindow, Ui_LogsWindow, object):
    def setupUi(self, MainWindow):
        MainWindow.setWindowTitle("GUI for Annotation")
        MainWindow.setObjectName("GUI for Annotation")
        MainWindow.resize(800, 640)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.initialized = False

        self.viewer_scene = QtWidgets.QGraphicsScene(self)
        self.viewer_image = ImageViewer(self.viewer_scene, self.centralwidget)
        self.shape_viewer = 300
        self.viewer_image.setScene(self.viewer_scene)
        self.viewer_image.setGeometry(QtCore.QRect(20, 80, 450, 450))
        self.viewer_image.viewport().setProperty("cursor", QtGui.QCursor(QtCore.Qt.CrossCursor))
        self.viewer_image.setObjectName("viewer_image")

        # Markers Box
        self.groupBox_markers = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_markers.setGeometry(QtCore.QRect(20, 10, 450, 60))
        self.groupBox_markers.setCheckable(False)
        self.groupBox_markers.setObjectName("markers")
        self.marker_layout = QtWidgets.QHBoxLayout()

        self.slider_stack = QtWidgets.QSlider(self.centralwidget)
        self.slider_stack.setGeometry(QtCore.QRect(20, 540, 450, 25))
        self.slider_stack.setOrientation(QtCore.Qt.Horizontal)  
        self.slider_stack.setMinimum(0)                        
        self.slider_stack.setMaximum(0)                        
        self.slider_stack.setTickPosition(QtWidgets.QSlider.TicksBelow)
        self.slider_stack.setTickInterval(1)                   
        self.slider_stack.setValue(0)                          
        self.slider_stack.setObjectName("slider_stack")
        self.slider_stack.valueChanged.connect(self.update_layer)

        self.button_previous = QtWidgets.QPushButton(self.centralwidget)
        self.button_previous.setGeometry(QtCore.QRect(500, 530, 120, 30))
        self.button_previous.setAutoFillBackground(False)
        self.button_previous.setAutoDefault(False)
        self.button_previous.setObjectName("button_previous")
        self.button_previous.clicked.connect(self.goToInstance)
        self.button_next = QtWidgets.QPushButton(self.centralwidget)
        self.button_next.setGeometry(QtCore.QRect(660, 530, 120, 30))
        self.button_next.setObjectName("button_next")
        self.button_next.clicked.connect(self.goToInstance)
        self.checkBox_bounding_boxes = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_bounding_boxes.setGeometry(QtCore.QRect(500, 30, 280, 20))
        self.checkBox_bounding_boxes.setObjectName("checkBox_boundingBoxes")
        self.checkBox_bounding_boxes.stateChanged.connect(self.show_bb_panel)
        self.checkBox_bounding_boxes.setEnabled(False)

        self.checkBox_semiautomatic_prediction = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_semiautomatic_prediction.setGeometry(QtCore.QRect(520, 60, 260, 20))
        self.checkBox_semiautomatic_prediction.setObjectName("checkBox_semiautomaticPrediction")

        self.groupBox_identity = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_identity.setGeometry(QtCore.QRect(500, 80, 280, 140))
        self.groupBox_identity.setObjectName("groupBox_identity")
        self.groupBox_morphology = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_morphology.setGeometry(QtCore.QRect(500, 240, 280, 200))
        self.groupBox_morphology.setObjectName("groupBox_morphology")

        self.label_instance = QtWidgets.QLabel(self.centralwidget)
        self.label_instance.setGeometry(QtCore.QRect(500, 560, 250, 31))
        self.label_instance.setAlignment(Qt.AlignCenter)
        self.label_instance.setObjectName("label_instance")
        self.label_layer = QtWidgets.QLabel(self.centralwidget)
        self.label_layer.setGeometry(QtCore.QRect(20, 560, 450, 16))
        self.label_layer.setAlignment(Qt.AlignCenter)
        self.label_layer.setObjectName("label")
        MainWindow.setCentralWidget(self.centralwidget)

        # Menu bar
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        MainWindow.setMenuBar(self.menubar)

        # Menus
        self.menuFile = QtWidgets.QMenu("File", self.menubar)
        self.menuLoad = QtWidgets.QMenu("Load", self.menubar)
        self.menuSettings = QtWidgets.QMenu("Settings", self.menubar)
        self.menuView = QtWidgets.QMenu("View", self.menubar)

        # Actions
        self.actionImage_File = QtWidgets.QAction("Image File", MainWindow)
        self.actionImage_File.triggered.connect(self.load_image)

        self.actionBounding_Boxes = QtWidgets.QAction("Bounding Boxes", MainWindow)
        self.actionBounding_Boxes.triggered.connect(self.load_bounding_boxes)

        self.actionLogs = QtWidgets.QAction("Show Logs", MainWindow)
        self.actionLogs.triggered.connect(self.open_logsWindow)

        self.actionSave_Labels = QtWidgets.QAction("Save Labels", MainWindow)
        self.actionSave_Labels.triggered.connect(self.save_labels)

        self.actionSave_New_Boxes = QtWidgets.QAction("Save New Boxes", MainWindow)
        self.actionSave_New_Boxes.triggered.connect(self.save_new_boxes)

        # Add actions to menus
        self.menuLoad.addAction(self.actionImage_File)
        self.menuLoad.addAction(self.actionBounding_Boxes)
        self.menuView.addAction(self.actionLogs)
        self.menuFile.addAction(self.actionSave_Labels)
        self.menuFile.addAction(self.actionSave_New_Boxes)

        # Add menus to the menubar
        self.menubar.addMenu(self.menuFile)
        self.menubar.addMenu(self.menuLoad)
        self.menubar.addMenu(self.menuView)
        self.menubar.addMenu(self.menuSettings)

        # Status bar
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.initial_state()

    def open_logsWindow(self):
        # Check if the new window is already open
        if self.logs_window is None:
            self.logs_window = Ui_LogsWindow()  # Create a new window instance
            self.sub_windows.append(self.logs_window)
        self.logs_window.show()
    
    def closeEvent(self, event):
        super().closeEvent(event)
        # Close all sub-windows when the main window is closed
        close = QtWidgets.QMessageBox()
        close.setText("You sure?")
        close.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel)
        close = close.exec()

        if close == QtWidgets.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()
        QtGui.QApplication.closeAllWindows()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.groupBox_markers.setTitle(_translate("MainWindow", "Markers"))
        self.button_previous.setText(_translate("MainWindow", "<< Previous"))
        self.button_next.setText(_translate("MainWindow", "Next >>"))
        self.checkBox_bounding_boxes.setText(_translate("MainWindow", "Bounding Boxes"))
        self.checkBox_semiautomatic_prediction.setText(_translate("MainWindow", "Semiautomatic Prediction"))
        self.groupBox_identity.setTitle(_translate("MainWindow", "Cell Identity"))
        self.groupBox_morphology.setTitle(_translate("MainWindow", "Cell Morphology"))
        self.label_layer.setText(_translate("MainWindow", "Instance Number:\n(/)"))
        self.label_layer.setText(_translate("MainWindow", "Layer"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.menuLoad.setTitle(_translate("MainWindow", "Load"))
        self.menuSettings.setTitle(_translate("MainWindow", "Settings"))
        self.actionImage_File.setText(_translate("MainWindow", "Image File"))
        self.actionBounding_Boxes.setText(_translate("MainWindow", "Bounding Boxes"))

    def initial_state(self):
        self.create_shortcuts()
        self.show_bb_panel(False)
        self.sub_windows = []
        self.logs_window = None
        self.open_logsWindow()
        self.image_path = None
        self.img_file = None
        self.csv_data_path = None
        self.csv_data = None
        self.current_layer = 0
        self.boundingBox_mode = 0
        self.current_bounding_box_ordinal = 0
        self.current_bounding_box_layer = 0
        self.compatibility = 0
        self.default_settings = {'morphology': ['Round', 'Branched', 'hBranched', 'Cluster', 'Other', 'Unknown']}
        self.class_labels = {}
        self.actionSave_Labels.setEnabled(False)
        self.actionSave_New_Boxes.setEnabled(False)
        self.checkBox_semiautomatic_prediction.hide()

        self.initialized = True
    
    def show_bb_panel(self, state:bool):
        if state == Qt.Checked or state:
            self.groupBox_identity.show()
            self.groupBox_morphology.show()
            self.label_instance.show()
            self.button_next.show()
            self.button_previous.show()
            self.boundingBox_mode = 1
            self.checkBox_semiautomatic_prediction.hide()

        else:
            self.groupBox_identity.hide()
            self.groupBox_morphology.hide()
            self.label_instance.hide()
            self.button_next.hide()
            self.button_previous.hide()
            self.boundingBox_mode = 0
            self.checkBox_semiautomatic_prediction.show()
        
        if self.initialized: 
            if state == Qt.Checked: self.goToInstance()
            else: self.draw_image()
    
    def load_image(self):
        for child in self.groupBox_markers.findChildren(QtWidgets.QRadioButton):
            child.setParent(None) 
            child.deleteLater() 

        self.image_path, _ = QtWidgets.QFileDialog.getOpenFileName(self,
                                                                   "Open Image",
                                                                   "",
                                                                   "Image Files " +
                                                                   "(*.tif; *.gz)" +
                                                                   ";;All Files (*)")
                
        if len(self.image_path) > 0:
            if os.path.basename(self.image_path).split(".")[-1] == "tif":
                self.img_file, msg = get_tif(self.image_path)
            elif os.path.basename(self.image_path).split(".")[-1] == "gz":
                self.img_file, msg = get_nibabel(self.image_path)
            else: print("Image not found.")
        
            self.list_markers = self.image_path.split('/')[-3].split('__')[1].split('_')
            self.list_markers.remove("DAPI")
            
            self.logs_window.update_message(message="<b>Selected Image</b>: " + os.path.basename(self.image_path) +\
                                                    "<br>Markers: " + str(self.list_markers)+\
                                                    "<br>Image Shape: " + str(self.img_file.shape))

            # Create Markers
            self.create_markers()
            radiobutton_marker0 = self.groupBox_markers.findChildren(QtWidgets.QRadioButton)[0]
            radiobutton_marker0.setChecked(True)
            self.selected_marker = 0

            self.green_boxes = []
            self.extra_csv_data = pd.DataFrame(columns=['File Name', 'Layer', 'Segmentation Number',
                                                        'Object Number', 'Area', 'Centroid', 'BoundingBox'])
            self.number_new_segmentations = 0

            self.ratio_row = self.shape_viewer/self.img_file.shape[0]
            self.ratio_col = self.shape_viewer/self.img_file.shape[1]

            self.draw_image()

            self.checkBox_bounding_boxes.setChecked(False)
            self.show_bb_panel(False)
            self.check_compatibility()

            self.create_identity_labels()
            self.create_morphology_labels()

    def load_bounding_boxes(self):
        self.csv_data_path, _ = QtWidgets.QFileDialog.getOpenFileName(self,
                                                                      "Open Image",
                                                                      "",
                                                                      "Image Files " +
                                                                      "(*.csv)" +
                                                                      ";;All Files (*)")
        self.csv_data = pd.read_csv(self.csv_data_path)

        self.logs_window.update_message("<b>Selected .csv File</b>: " + \
                                        os.path.basename(self.csv_data_path))

        self.checkBox_bounding_boxes.setChecked(False)
        self.show_bb_panel(False)
        self.check_compatibility()
        
    def check_compatibility(self):
        if self.csv_data_path and self.image_path:
            self.image_name = os.path.basename(self.image_path).split('.')[0]
            if self.image_name in list(self.csv_data['File Name']):
                self.compatibility = True
                self.logs_window.update_message('The image and .csv file uploaded are compatible!')
                self.checkBox_bounding_boxes.setEnabled(True)
                self.checkBox_semiautomatic_prediction.show()
                self.filtered_csv_data = self.csv_data[self.csv_data['File Name'] == self.image_name]
                self.draw_boxes()
                self.actionSave_Labels.setEnabled(True)
                self.actionSave_New_Boxes.setEnabled(True)
    
            else: 
                self.compatibility = False
                self.logs_window.update_message('The image and .csv file uploaded are NOT compatible!')
                self.checkBox_bounding_boxes.setEnabled(False)
                self.checkBox_semiautomatic_prediction.hide()
                self.actionSave_Labels.setEnabled(False)
                self.actionSave_New_Boxes.setEnabled(False)
    
    def draw_image(self):
        if self.boundingBox_mode == 0:
            clahe = cv2.createCLAHE(clipLimit=5.0, tileGridSize=(8, 8))
            enhanced_img = clahe.apply(self.img_file[:, :,
                                                     self.current_layer,
                                                     self.selected_marker]
                                       .astype('uint8'))
                       
        elif self.boundingBox_mode:
            layer = self.bounding_box_csv_data.\
                    iloc[self.current_bounding_box_layer]['Layer']
            
            current_bb_pos = self.bounding_box_csv_data[self.bounding_box_csv_data['Layer'] == layer]['BoundingBox'].values[0]

            try:
                current_bb_pos = ast.literal_eval(current_bb_pos)
            except:
                pass

            offset = 100

            row1 = round(current_bb_pos[1]) - offset
            col1 = round(current_bb_pos[2]) - offset
            row2 = round(current_bb_pos[4]) + offset
            col2 = round(current_bb_pos[5]) + offset

            row_center = round((row2-row1)/2)
            col_center = round((col2-col1)/2)

            if row1 < 0:
                row2 += (0-row1)
                row_center += (0-row1)
                row1 = 0
            elif row2 > self.img_file.shape[0]:
                row1 -= (row2 - self.img_file.shape[0])
                row_center -= (row2 - self.img_file.shape[0])
                row2 = self.img_file.shape[0]

            if col1 < 0:
                col2 += (0-col1)
                col_center += (0-col1)
                col1 = 0
            elif col2 > self.img_file.shape[1]:
                col1 -= (col2 - self.img_file.shape[1])
                col_center -= (col2 - self.img_file.shape[1])
                col2 = self.img_file.shape[1]

            current_bb_img = self.img_file[row1:row2, col1:col2, :, :]

            clahe = cv2.createCLAHE(clipLimit=5.0, tileGridSize=(8, 8))
            enhanced_img = clahe.apply(current_bb_img[:, :,
                                                      layer,
                                                      self.selected_marker]
                                    .astype('uint8'))

        resized_img = cv2.resize(enhanced_img, (self.shape_viewer, self.shape_viewer),
                                 interpolation=cv2.INTER_AREA)
        
        height, width = resized_img.shape
        bytesPerLine = width
        qImg = QImage(resized_img.astype('uint8').data, width, height,
                      bytesPerLine, QImage.Format_Grayscale8)
        pixmap = QPixmap.fromImage(qImg)
        self.viewer_scene.clear()
        self.viewer_scene.addPixmap(pixmap)
        self.viewer_image.setSceneRect(QRectF(pixmap.rect()))
        self.viewer_image.fitInView(self.viewer_scene.itemsBoundingRect(),
                                    Qt.KeepAspectRatio)
        
        if self.boundingBox_mode:
            ratio_row = self.shape_viewer/(row2 - row1)
            ratio_col = self.shape_viewer/(col2 - col1)
            rect = BoundingBox(self.shape_viewer-ratio_col*col_center-2,
                               self.shape_viewer-ratio_row*row_center-2,
                               3, 3,
                               False,
                               type="center")
            self.viewer_scene.addItem(rect)
        else:
            if self.compatibility: self.draw_boxes()
            elif len(self.extra_csv_data): self.draw_boxes(mode='extra_boxes')

        if self.boundingBox_mode: 
            if self.slider_stack.value != self.current_bounding_box_layer: self.slider_stack.setValue(self.current_bounding_box_layer)
            self.label_layer.setText("Layer: %s/%s" % (str(self.current_bounding_box_layer+1), str(self.slider_stack.maximum()+1)))
        else: 
            self.slider_stack.setMaximum(self.img_file.shape[2]-1)
            if self.slider_stack.value != self.current_layer: self.slider_stack.setValue(self.current_layer)
            self.label_layer.setText("Layer: %s/%s" % (str(self.current_layer+1), str(self.img_file.shape[2])))

    def draw_boxes(self, mode:str='all'):    
        if mode == 'all':
            if len(self.extra_csv_data):
                interest_csv_data = self.filtered_csv_data[self.filtered_csv_data['Layer'] == self.current_layer]
                interest_green_boxes_data = self.extra_csv_data[self.extra_csv_data['Layer'] == self.current_layer]

                bounding_boxes = []

                for csv_data in [interest_csv_data, interest_green_boxes_data]:
                    for box in csv_data['BoundingBox']:
                        try: box = ast.literal_eval(box)
                        except: pass
                        bounding_boxes.append(box)                
                
                instances = [inst for inst in
                                interest_csv_data['Segmentation Number']] +\
                            [inst for inst in
                                interest_green_boxes_data['Segmentation Number']]
            
            else: 
                interest_csv_data = self.filtered_csv_data[self.filtered_csv_data['Layer'] == self.current_layer]
                bounding_boxes = list([ast.literal_eval(box) for box in
                                    interest_csv_data['BoundingBox']]) 
                instances = [inst for inst in
                                interest_csv_data['Segmentation Number']]
        
        elif mode == 'extra_boxes':
            interest_green_boxes_data = self.extra_csv_data[self.extra_csv_data['Layer'] == self.current_layer]

            bounding_boxes = interest_green_boxes_data['BoundingBox']
            
            instances = [inst for inst in
                            interest_green_boxes_data['Segmentation Number']]
            
        if len(bounding_boxes) > 0:
            for i, (_, x1, y1, _, x2, y2) in enumerate(bounding_boxes):
                x1 *= self.ratio_row
                y1 *= self.ratio_col
                x2 *= self.ratio_row
                y2 *= self.ratio_col
                width = x2 - x1
                height = y2 - y1
                rect = BoundingBox(y1, x1, height, width,
                                    False)
                self.viewer_scene.addItem(rect)

                label_item = QtWidgets.QGraphicsTextItem(str(instances[i]))
                label_item.setFont(QFont("Arial", 6, weight=4))
                label_item.setDefaultTextColor(QColor(0, 255, 255))
                label_item.setPos((y1+y2)/2 - 10, (x1+x2)/2 - 10)
                self.viewer_scene.addItem(label_item)
       
    def create_markers(self):
        list_all_markers = self.image_path.split('/')[-3].split('__')[1].split('_')

        for marker in list_all_markers:
            markern_radio = QtWidgets.QRadioButton(marker)
            markern_radio.clicked.connect(self.update_selected_marker)
            markern_radio.setObjectName(marker)
            self.marker_layout.addWidget(markern_radio)
        self.groupBox_markers.setLayout(self.marker_layout)
    
    def update_selected_marker(self):
        for marker_n, markern_radio in enumerate(self.groupBox_markers.findChildren(QtWidgets.QRadioButton)):
            if self.sender() == markern_radio or markern_radio.isChecked(): 
                self.selected_marker = marker_n

        if self.image_path is not None:
            self.draw_image()

    def update_layer(self):
        if self.boundingBox_mode:
            self.current_bounding_box_layer = self.slider_stack.value()
        else:
            self.extract_green_boxes()
            self.current_layer = self.slider_stack.value()
        
        try:
            self.draw_image()
        except:
            pass
    
    def goToInstance(self):
        if self.boundingBox_mode:
            number_boundingBoxes = len(list(set(self.filtered_csv_data['Segmentation Number'])))                    # number of bounding boxes in the images
            if self.sender() == self.button_previous or self.sender() == self.previous_instance_shortcut:
                if self.current_bounding_box_ordinal > 0:
                    self.current_bounding_box_ordinal -= 1
            elif self.sender() == self.button_next or self.sender() == self.next_instance_shortcut:
                if self.current_bounding_box_ordinal < number_boundingBoxes - 1:   # ordinal number of current bounding box 
                    self.current_bounding_box_ordinal += 1
            else: self.current_bounding_box_ordinal == 0
            
            self.current_bounding_box_real = list(set(self.filtered_csv_data['Segmentation Number']))\
                                                                        [self.current_bounding_box_ordinal]                 # real number of current bounding box number
            
            self.label_instance.setText(f'Instance Number: {self.current_bounding_box_real}\n({self.current_bounding_box_ordinal+1}/{number_boundingBoxes})')

            self.current_bounding_box_layer = 0
            self.slider_stack.setValue(self.current_bounding_box_layer)

            depth_current_bounding_box = len(self.filtered_csv_data[self.filtered_csv_data['Segmentation Number'] == self.current_bounding_box_real]["Layer"])
            self.slider_stack.setMaximum(depth_current_bounding_box-1)

            self.bounding_box_csv_data = self.filtered_csv_data[self.filtered_csv_data['Segmentation Number'] == self.current_bounding_box_real]

            self.draw_image()
            self.update_labels()
            
            if self.checkBox_semiautomatic_prediction.isChecked(): 
                self.semiautomatic_predict_labels()

    def create_identity_labels(self):
        self.layout_identity = QtWidgets.QVBoxLayout()
        self.remove_layout(self.groupBox_identity)

        for marker in self.list_markers:
            checkBox_label = QtWidgets.QCheckBox(marker)
            checkBox_label.clicked.connect(self.select_labels)
            checkBox_label.setTristate(True)
            checkBox_label.setObjectName(marker)
            self.layout_identity.addWidget(checkBox_label)
        
        self.groupBox_identity.setLayout(self.layout_identity)
    
    def create_morphology_labels(self):
        self.layout_morphology = QtWidgets.QVBoxLayout()
        self.remove_layout(self.groupBox_morphology)

        for morphology in self.default_settings['morphology']:
            checkBox_label = QtWidgets.QRadioButton(morphology)
            checkBox_label.clicked.connect(self.select_labels)
            self.layout_morphology.addWidget(checkBox_label)
        
        self.groupBox_morphology.setLayout(self.layout_morphology)

    def select_labels(self):
        """
        Update the class labels dictionary (self.class_labels) with the morphology and marker label.
        For the Astrocyte mode.
        """
        morphology_label = None
        identity_label = dict.fromkeys(self.list_markers)

        for morphology_n, morphology_button in enumerate(self.groupBox_morphology.findChildren(QtWidgets.QRadioButton)):
            if self.sender() == morphology_button: 
                morphology_label = self.default_settings['morphology'][morphology_n]

        for identity_n, identity_button in enumerate(self.groupBox_identity.findChildren(QtWidgets.QCheckBox)):
            if self.sender() == identity_button or identity_button.isChecked(): 
                if identity_button.checkState() == Qt.Checked:
                    identity_label[self.list_markers[identity_n]] = "Positive"
                elif identity_button.checkState() == Qt.PartiallyChecked:
                    identity_label[self.list_markers[identity_n]] = "Negative"
                else: 
                    identity_label[self.list_markers[identity_n]] = "Unknown"

        indexes = self.bounding_box_csv_data.index

        for index in indexes: 
            if index not in self.class_labels.keys():
                markers_labels = [f"{marker} Label" for marker in self.list_markers]
                self.class_labels[index] = dict.fromkeys(['Morphology Label'] + \
                                                          markers_labels)

            if morphology_label:
                self.class_labels[index]['Morphology Label'] = morphology_label

            for marker in identity_label.keys():
                if identity_label[marker]:
                    self.class_labels[index][f"{marker} Label"] = identity_label[marker]
                    
    def update_labels(self):
        self.clear_labels()
        indexes = self.bounding_box_csv_data.index     

        for index in indexes:
            if index not in self.class_labels.keys():
                markers_labels = [f"{marker} Label" for marker in self.list_markers]
                self.class_labels[index] = dict.fromkeys(['Morphology Label'] + \
                                                        markers_labels)

                for morphology_n, morphology in enumerate(self.default_settings['morphology']):
                    if self.csv_data.loc[index, 'Morphology Label'] == morphology: 
                        self.groupBox_morphology.findChildren(QtWidgets.QRadioButton)[morphology_n].setChecked(True)
                        self.class_labels[index]['Morphology Label'] = morphology
                    else: 
                        self.groupBox_morphology.findChildren(QtWidgets.QRadioButton)[morphology_n].setChecked(False)

                for identity_n, identity_button in enumerate(self.groupBox_identity.findChildren(QtWidgets.QCheckBox)):
                    if self.csv_data.loc[index, f"{self.list_markers[identity_n]} Label"] == 'Positive': 
                        identity_button.setCheckState(Qt.Checked)
                        self.class_labels[index][f"{self.list_markers[identity_n]} Label"] = 'Positive'

                    elif self.csv_data.loc[index, f"{self.list_markers[identity_n]} Label"] == 'Negative': 
                        identity_button.setCheckState(Qt.PartiallyChecked)
                        self.class_labels[index][f"{self.list_markers[identity_n]} Label"] = 'Negative'
                    # elif self.csv_data.loc[index, f"{self.list_markers[identity_n]} Label"] == 'Negative': 
                    else:
                        identity_button.setCheckState(Qt.Unchecked)
                        self.class_labels[index][f"{self.list_markers[identity_n]} Label"] = 'Unknown'


            if index in self.class_labels.keys():
                for morphology_n, morphology in enumerate(self.default_settings['morphology']):
                    if self.class_labels[index]['Morphology Label'] == morphology:
                        self.groupBox_morphology.findChildren(QtWidgets.QRadioButton)[morphology_n].setChecked(True)
                    else:
                        self.groupBox_morphology.findChildren(QtWidgets.QRadioButton)[morphology_n].setChecked(False)
                    
                for identity_n, identity_button in enumerate(self.groupBox_identity.findChildren(QtWidgets.QCheckBox)):
                    if self.class_labels[index][f"{self.list_markers[identity_n]} Label"] == 'Positive': 
                        identity_button.setCheckState(Qt.Checked)
                    elif self.class_labels[index][f"{self.list_markers[identity_n]} Label"] == 'Negative': 
                        identity_button.setCheckState(Qt.PartiallyChecked)
                    # elif self.csv_data.loc[index, f"{self.list_markers[identity_n]} Label"] == 'Negative': 
                    else:
                        identity_button.setCheckState(Qt.Unchecked)
    
    def clear_labels(self):
        for morphology_button in self.groupBox_morphology.findChildren(QtWidgets.QRadioButton):
            morphology_button.setAutoExclusive(False)
            morphology_button.setChecked(False)
            morphology_button.setAutoExclusive(True)

        for identity_checkbox in self.groupBox_identity.findChildren(QtWidgets.QCheckBox):
            identity_checkbox.setChecked(False)

    def save_labels(self):
        if len(self.class_labels) > 0:            
            directory_path = os.path.dirname(self.image_path)
            file_name = os.path.basename(self.image_path)
            base_name, extension = os.path.splitext(file_name)

            for key in self.class_labels.keys():
                if self.class_labels[key]['Morphology Label']:
                    self.csv_data.loc[key, 'Morphology Label'] = self.class_labels[key]['Morphology Label']
                for marker_label in self.list_markers:
                    if self.class_labels[key][f"{marker_label} Label"]:
                        self.csv_data.loc[key, f"{marker_label} Label"] = self.class_labels[key][f"{marker_label} Label"]

            self.csv_data.to_csv(self.csv_data_path, index=False)
            message = "The cell instances' labels were saved to: <br>" + self.csv_data_path

            self.logs_window.update_message(message)
        
        else:
            self.logs_window.update_message("There aren't any new labels to save. The file is up to date!")

        self.filtered_csv_data = self.csv_data[self.csv_data['File Name'] == self.image_name]
    
    def save_new_boxes(self):
        if len(self.extra_csv_data) > 0:

            next_segmentation_number = self.filtered_csv_data['Segmentation Number'].max() + 1
            self.extra_csv_data['Segmentation Number'] = self.extra_csv_data['Segmentation Number'] + next_segmentation_number

            df = pd.concat([self.csv_data, self.extra_csv_data],
                            ignore_index=True)

            self.csv_data = df
            self.filtered_csv_data = self.csv_data[self.csv_data['File Name'] == self.image_name]

            options = QtWidgets.QFileDialog.Options()
            file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
                self,
                "Save CSV File",
                "",
                "CSV Files (*.csv);;All Files (*)",
                options=options
            )

            if file_path:  # Only proceed if a file was selected
                try:
                    # Example: data to save (replace with your actual data)

                    # Write data to the selected file
                    with open(file_path, mode="w", newline="", encoding="utf-8") as file:
                        df.to_csv(file, index=False)

                    QtWidgets.QMessageBox.information(self, "Success", f"File saved successfully: {file_path}")

                except Exception as e:
                    QtWidgets.QMessageBox.critical(self, "Error", f"Failed to save file: {e}")
            
        else:
            self.logs_window.update_message("There aren't any new boxes to save.<br>If you drew new boxes, make sure you selected them (green box appeared).")
    def semiautomatic_predict_labels(self):
        layers = self.bounding_box_csv_data['Layer']
        indexes = self.bounding_box_csv_data.index

        for identity_n, identity_label in enumerate(self.list_markers):
            if (all([self.class_labels[index][f"{identity_label} Label"] not in ["Positive", "Negative"]
                    for index in indexes 
                    if index in self.class_labels.keys()])\
               and all([self.bounding_box_csv_data.loc[index][f"{identity_label} Label"] not in ["Positive", "Negative"]
                        for index in indexes])):
                layer1 = layers.min()
                layer2 = layers.max()

                x1, y1, x2, y2 = (512, 512, 0, 0)
                offset = 20

                for index in indexes:
                    try:
                        _, x1new, y1new, _, x2new, y2new = ast.literal_eval(self.filtered_csv_data.loc[index, 'BoundingBox'])
                    except: 
                        _, x1new, y1new, _, x2new, y2new = self.filtered_csv_data.loc[index, 'BoundingBox']
                    if x1new - offset < x1: x1 = x1new
                    if y1new - offset < y1: y1 = y1new
                    if x2new + offset > x2: x2 = x2new
                    if y2new + offset > y2: y2 = y2new
                
                if x1 < 0: x1 = 0
                if y1 < 0: y1 = 0
                if x2 > 512: x2 = 512
                if y2 > 512: y2 = 512

                bb3d_img = self.img_file[x1:x2, y1:y2, layer1:layer2, identity_n]
                bb3d_intensity = bb3d_img.mean()
                median_intensity = np.median(self.img_file[identity_n])

                for index in indexes:
                    if index not in self.class_labels.keys():
                        markers_labels = [f"{marker} Label" for marker in self.list_markers]
                        self.class_labels[index] = dict.fromkeys(['Morphology Label'] + \
                                                                    markers_labels)
                    if bb3d_intensity > 2*median_intensity: 
                        self.class_labels[index][f"{identity_label} Label"] = "Positive"
                    else: 
                        self.class_labels[index][f"{identity_label} Label"] = "Negative"

        self.update_labels()

    
    def extract_green_boxes(self):
        ratio_row = 1/self.ratio_row
        ratio_col = 1/self.ratio_col

        file_name = os.path.basename(self.image_path)

        for item in self.viewer_scene.items():
            if isinstance(item, BoundingBox) and item.pen().color() == Qt.green:
                rect = item.rect()
                x1 = round(ratio_row*rect.y())
                y1 = round(ratio_col*rect.x())
                x2 = round(ratio_row*(rect.y()+rect.height()))
                y2 = round(ratio_col*(rect.x()+rect.width()))
                data = {
                    'File Name': file_name.split('.')[0],
                    'Layer': self.current_layer,
                    'Segmentation Number': self.number_new_segmentations,
                    'Object Number': -1,
                    'Area': (x2-x1)*(y2-y1),
                    'Centroid': ((x2+x1)/2, (y2+y1)/2),
                    'BoundingBox': (-1, x1, y1, -1, x2, y2),
                }
                
                self.green_boxes.append(data)
                self.number_new_segmentations = self.number_new_segmentations + 1
                    
        self.extra_csv_data = pd.DataFrame(self.green_boxes)

    
    def remove_layout(self, groupbox):
        if groupbox.layout() is not None:
            # Remove the layout
            layout = groupbox.layout()
            
            # Clear all widgets from the layout
            while layout.count():
                child = layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
            
            # Delete the layout
            # groupbox.setLayout(None)

    def change_selected_marker(self):
        groupBox_markers_childs = self.groupBox_markers.findChildren(QtWidgets.QRadioButton)
        for marker_n, markern_radio in enumerate(groupBox_markers_childs):
            if markern_radio.isChecked():
                markern_radio.setChecked(False)
                i = (marker_n + 1) % len(groupBox_markers_childs)
                groupBox_markers_childs[i].setChecked(True)
                break
        
        self.update_selected_marker()

    def change_marker_label(self):
        if self.boundingBox_mode:
            groupBox_markers_children = self.groupBox_markers.findChildren(QtWidgets.QRadioButton)
            for marker_n, markern_radio in enumerate(groupBox_markers_children):
                if markern_radio.isChecked():
                    marker_name = markern_radio.objectName()
                    print(marker_name)
                    try:
                        identity_child = self.groupBox_identity.findChild(QtWidgets.QCheckBox, marker_name)
                        print(identity_child.objectName())
                        state = identity_child.checkState()
                        if state == Qt.Checked: identity_child.setCheckState(Qt.Unchecked)
                        elif state == Qt.Unchecked: identity_child.setCheckState(Qt.PartiallyChecked)
                        elif state == Qt.PartiallyChecked: identity_child.setCheckState(Qt.Checked)
                        self.select_labels()
                    except:
                        pass
                    break

    def change_layer(self):
        if self.sender() == self.change_previous_layer_shortcut:
            if self.slider_stack.value() > 0:
                self.slider_stack.setValue(self.slider_stack.value()-1)
                self.update_layer()
        elif self.sender() == self.change_next_layer_shortcut:
            if self.slider_stack.value() <= self.slider_stack.maximum():
                self.slider_stack.setValue(self.slider_stack.value()+1)
                self.update_layer()
            
    def create_shortcuts(self):
        print("shortcuts created")
        change_marker_shortcut = QtWidgets.QShortcut(Qt.Key_Space, self.centralwidget)
        change_marker_shortcut.setContext(Qt.ApplicationShortcut)
        change_marker_shortcut.activated.connect(self.change_selected_marker)

        change_marker_label_shortcut = QtWidgets.QShortcut(Qt.Key_Return, self.centralwidget)
        change_marker_label_shortcut.setContext(Qt.ApplicationShortcut)
        change_marker_label_shortcut.activated.connect(self.change_marker_label)

        self.change_next_layer_shortcut = QtWidgets.QShortcut(Qt.Key_Right, self.centralwidget)
        self.change_next_layer_shortcut.setContext(Qt.ApplicationShortcut)
        self.change_next_layer_shortcut.activated.connect(self.change_layer)

        self.change_previous_layer_shortcut = QtWidgets.QShortcut(Qt.Key_Left, self.centralwidget)
        self.change_previous_layer_shortcut.setContext(Qt.ApplicationShortcut)
        self.change_previous_layer_shortcut.activated.connect(self.change_layer)

        self.next_instance_shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Shift+Right"), self.centralwidget)
        self.next_instance_shortcut.setContext(Qt.ApplicationShortcut)
        self.next_instance_shortcut.activated.connect(self.goToInstance)

        self.previous_instance_shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Shift+Left"), self.centralwidget)
        self.previous_instance_shortcut.setContext(Qt.ApplicationShortcut)
        self.previous_instance_shortcut.activated.connect(self.goToInstance)
